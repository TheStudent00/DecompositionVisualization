<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Singular Vector Selector</title>
  <style>
    body { margin:0; display:flex; height:100vh; background:#000; }
    #left-panel { width:200px; background:#1a1a1a; color:#fff; padding:10px; border-right:1px solid #333; flex-shrink:0; }
    #right-panel { flex-grow:1; position:relative; width:calc(100% - 200px); }
    .math-object { cursor:pointer; margin:10px 0; padding:5px; background:#333; border-radius:3px; text-align:center; color:#fff; }
    #matrix-display { position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,.5); color:#fff; padding:10px; border-radius:5px; font-family:'Courier New', monospace; }
  </style>
</head>
<body>
  <div id="tutorial-video" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:50%; background:#333; padding:20px; border-radius:8px; box-shadow:0 0 15px rgba(0,0,0,.5); z-index:1000; display:none; text-align:center;">
    <iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/_rmd7PpEITU?si=fSsA0UVxC39VM6xw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    <div style="color:#fff; margin-top:10px; text-align:left;">
      <h3>Instructions:</h3>
      <ol>
        <li>Generate a random 3×3 matrix \(A\) via SVD: \(A = U\Sigma V^T\).</li>
        <li>Rotate the view so the three plotted columns of \(A\) look as “small” as possible; that view direction approximates the top singular vector of \(A^TA\) (PCA view).</li>
        <li>Submit your guess; accuracy is cosine similarity to the true first left singular vector \(u_1\).</li>
      </ol>
    </div>
    <button id="close-tutorial" style="position:absolute; top:10px; right:10px; padding:5px 10px; background:#444; border:1px solid #666; color:#fff; font-size:1em; cursor:pointer; border-radius:3px;">&times;</button>
  </div>

  <div id="left-panel">
    <div class="math-object" id="generate-matrix">Generate Random Matrix</div>
    <div class="math-object" id="submit-guess">Submit Dominant Singular Vector Guess</div>
    <div id="selection-accuracy-container" style="border:1px solid #666; padding:10px; margin-top:20px; text-align:center; font-weight:bold;">
      <div>Selection Accuracy:</div>
      <div id="selection-accuracy" style="border:1px solid #666; padding:10px; margin-top:20px; text-align:center; font-weight:bold;">
        <p>...</p>
      </div>
    </div>
    <div class="math-object" id="tutorial-button" style="margin-bottom:auto;">Show Tutorial</div>
  </div>

  <div id="right-panel">
    <div id="plotly-div" style="width:100%; height:100%;"></div>
    <div id="matrix-display"></div>
  </div>

  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    // --- Small linear algebra helpers (to avoid missing numeric.transpose) ---
    function transpose(A){ return A[0].map((_,j)=>A.map(row=>row[j])); }
    function dotProduct(v1, v2){ return v1.reduce((s,_,i)=>s+v1[i]*v2[i],0); }
    function normalizeVector(v){ const n=Math.sqrt(dotProduct(v,v)); return v.map(x=>x/n); }

    // Rotation about Z and X
    function Rz(a){
      const c=Math.cos(a), s=Math.sin(a);
      return [[c,-s,0],[s,c,0],[0,0,1]];
    }
    function Rx(a){
      const c=Math.cos(a), s=Math.sin(a);
      return [[1,0,0],[0,c,-s],[0,s,c]];
    }

    // Full 3-DOF rotation via Z–X–Z; optional random reflection for det = -1
    function generateRandomOrthogonal(){
      // base rotation in SO(3)
      const theta = Math.random()*2*Math.PI;  // Z
      const phi   = Math.random()*2*Math.PI;  // X
      const gamma = Math.random()*2*Math.PI;  // Z
      const R = numeric.dot(numeric.dot(Rz(theta), Rx(phi)), Rz(gamma));
    
      // with 50% probability, flip handedness using a single-axis reflection
      if (Math.random() < 0.5) {
        // pick one axis uniformly to reflect
        const pick = Math.floor(Math.random()*3); // 0=x,1=y,2=z
        const D = [
          [pick===0 ? -1 : 1, 0, 0],
          [0, pick===1 ? -1 : 1, 0],
          [0, 0, pick===2 ? -1 : 1]
        ];
        return numeric.dot(R, D); // now in O(3) with det = -1
      }
      return R; // det = +1
    }

    function generateNormal(mean=0.0, std=1.0){
      const u1=Math.random(), u2=Math.random();
      const z=Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
      return z*std+mean;
    }

    // --- App state ---
    let generatedMatrix = null;
    let generatedMatrix_t = null;
    let firstSingularVector = null; // u1 from U
    let buffer = 1.0;
    let randomSigma = null;
    let randomU = null;
    let randomV = null;
    let randomV_t = null;

    // SVD-based generator: A = U Σ V^T
    function generateRandomMatrix(){
      // 1) Uniform(ish) random rotations for U, V (SO(3))
      randomU = generateRandomOrthogonal();
      randomV = generateRandomOrthogonal();
      randomV_t = transpose(randomV);

      // 2) Positive singular values, sorted by magnitude (visual stability)
      let s = [Math.abs(generateNormal(0,1)), Math.abs(generateNormal(0,1)), Math.abs(generateNormal(0,1))];
      // prevent degeneracy; bias for reasonable spread
      s = s.map(v => 0.3 + v);                     // floor
      s.sort((a,b)=>b-a);                          // σ1 ≥ σ2 ≥ σ3
      randomSigma = [[s[0],0,0],[0,s[1],0],[0,0,s[2]]];

      // 3) Assemble A
      generatedMatrix = numeric.dot(numeric.dot(randomU, randomSigma), randomV_t);
      generatedMatrix_t = transpose(generatedMatrix);

      // Store u1 (first left singular vector) for comparison
      const U_t = transpose(randomU);
      firstSingularVector = normalizeVector(U_t[0]);

      plotMatrix(generatedMatrix_t);
      displayMatrix();
      // Reset accuracy view
      const resultDiv=document.getElementById('selection-accuracy'); resultDiv.innerHTML='<p>...</p>';
    }

    function displayMatrix(){
      if(!generatedMatrix) return;
      const md = document.getElementById('matrix-display');
      let tex = `\\[
      \\begin{array}{c@{\\hspace{1cm}}c@{\\hspace{1cm}}c}
      \\text{A} & = & U\\,\\Sigma\\,V^{\\!T}\\\\
      \\begin{bmatrix}`;
      generatedMatrix.forEach((row,i)=>{
        tex += row.map(v=>v.toFixed(2)).join(' & ');
        if(i<2) tex += ' \\\\ ';
      });
      tex += `\\end{bmatrix}
      \\end{array}
      \\]`;
      md.innerHTML = tex;
      MathJax.typesetPromise([md]);
    }

    function plotMatrix(Mt){
      // Auto range from longest column of A
      const lens = Mt.map(col => Math.sqrt(dotProduct(col,col)));
      const maxLen = Math.max(...lens);
      buffer = Math.max(1.2*maxLen, 1.0);

      const traces = Mt.map((col,idx)=>({
        type:'scatter3d', mode:'lines+markers',
        x:[0,col[0]], y:[0,col[1]], z:[0,col[2]],
        line:{ width:6, color:['#00FFFF','#00CED1','#40E0D0'][idx%3], opacity:0.85 },
        marker:{ size:4, color:['#00FFFF','#00CED1','#40E0D0'][idx%3], opacity:0.85 },
        name:`A column ${idx+1}`
      }));

      const layout = {
        scene:{
          xaxis:{range:[-buffer,buffer], title:'X'},
          yaxis:{range:[-buffer,buffer], title:'Y'},
          zaxis:{range:[-buffer,buffer], title:'Z'},
          aspectmode:'cube',
          camera:{eye:{x:1,y:1,z:1}}
        },
        paper_bgcolor:'black', plot_bgcolor:'black',
        title:"Singular Vector (PCA) View",
        font:{color:'white'}
      };

      Plotly.newPlot('plotly-div', traces, layout);
    }

    function getCameraPosition(){
      const scene = document.getElementById('plotly-div')._fullLayout.scene._scene;
      const eye = scene.getCamera().eye;
      return [eye.x, eye.y, eye.z];
    }

    function calculateCosineSimilarity(v1,v2){
      return dotProduct(v1,v2) / Math.sqrt(dotProduct(v1,v1)*dotProduct(v2,v2));
    }

    function handleFirstSingularGuessSubmission(){
      if(!generatedMatrix) return;
      const guess = normalizeVector(getCameraPosition());
      const truth = firstSingularVector; // u1
      const acc = Math.abs(calculateCosineSimilarity(truth, guess))*100;
      const div = document.getElementById('selection-accuracy');
      div.innerHTML = `<p>${acc.toFixed(2)}%</p>`;
      plotSingularVectorComparison(guess);
    }

    function getComputedSingularVector(A){
      const svd = numeric.svd(A);
      // numeric.svd returns U with columns = left singular vectors
      const U = svd.U;
      const U_t = transpose(U);
      return normalizeVector(U_t[0]);
    }

    function plotSingularVectorComparison(guess){
      const u_true = firstSingularVector;
      const u_comp = getComputedSingularVector(generatedMatrix);
      const u_guess = normalizeVector(guess);

      const vTrue = {type:'scatter3d', mode:'lines+markers',
        x:[-u_true[0], u_true[0]], y:[-u_true[1], u_true[1]], z:[-u_true[2], u_true[2]],
        line:{width:6, dash:'dash', color:'green', opacity:.9},
        marker:{size:1, color:'green', opacity:.9},
        name:'True u₁'
      };
      const vComp = {type:'scatter3d', mode:'lines+markers',
        x:[-u_comp[0], u_comp[0]], y:[-u_comp[1], u_comp[1]], z:[-u_comp[2], u_comp[2]],
        line:{width:6, dash:'dot', color:'blue', opacity:.9},
        marker:{size:1, color:'blue', opacity:.9},
        name:'Computed u₁ (svd)'
      };
      const vGuess = {type:'scatter3d', mode:'lines+markers',
        x:[0, u_guess[0]], y:[0, u_guess[1]], z:[0, u_guess[2]],
        line:{width:6, dash:'dash', color:'magenta', opacity:.9},
        marker:{size:1, color:'magenta', opacity:.9},
        name:'Your guess'
      };

      const Mt = generatedMatrix_t.map(col=>col.slice()); // copy
      const Acols = Mt.map((col,idx)=>({
        type:'scatter3d', mode:'lines+markers',
        x:[0,col[0]], y:[0,col[1]], z:[0,col[2]],
        line:{width:6, color:['#00FFFF','#00CED1','#40E0D0'][idx%3], opacity:.85},
        marker:{size:4, color:['#00FFFF','#00CED1','#40E0D0'][idx%3], opacity:.85},
        name:`A column ${idx+1}`
      }));

      const layout = {
        scene:{
          xaxis:{range:[-buffer,buffer], title:'X'},
          yaxis:{range:[-buffer,buffer], title:'Y'},
          zaxis:{range:[-buffer,buffer], title:'Z'},
          aspectmode:'cube'
        },
        paper_bgcolor:'black', plot_bgcolor:'black',
        title:"Singular Vector (PCA) View",
        font:{color:'white'}
      };

      Plotly.newPlot('plotly-div', [vComp, vTrue, ...Acols, vGuess], layout);
    }

    // UI wiring
    document.getElementById('close-tutorial').addEventListener('click', ()=> {
      document.getElementById('tutorial-video').style.display='none';
    });
    document.addEventListener('DOMContentLoaded', ()=>{
      document.getElementById('generate-matrix').addEventListener('click', generateRandomMatrix);
      document.getElementById('submit-guess').addEventListener('click', handleFirstSingularGuessSubmission);
      document.getElementById('tutorial-button').addEventListener('click', ()=>{
        const t = document.getElementById('tutorial-video');
        t.style.display = (t.style.display==='none') ? 'block' : 'none';
      });
    });
  </script>
</body>
</html>
